# BFF Gateway Integration Tests

This project contains comprehensive integration tests for the Eroad BFF Gateway API that run against the Docker-hosted BFF Gateway instance.

## Overview
These tests verify the BFF Gateway functionality by making real HTTP calls to the BFF Gateway running in Docker, which communicates with all backend microservices.

## Prerequisites

Before running tests, ensure all services are running via Docker Compose:

```powershell
# Start all services
docker-compose --profile init-services up -d

# Verify services are running
docker-compose ps

# Verify BFF Gateway is accessible
curl http://localhost:5000
```

## Running the Tests

### From Command Line

```powershell
# Run all tests
dotnet test

# Run with verbose output
dotnet test -v n

# Run specific test class
dotnet test --filter "FullyQualifiedName~BFFGatewayIntegrationTests"

# Run specific test
dotnet test --filter "FullyQualifiedName~BFFGatewayIntegrationTests.AddVehicle_CreatesNewVehicle"
```

### From Visual Studio / VS Code
Use the Test Explorer to run individual tests or all tests.

## Configuration

### BFF Base URL
By default, tests connect to `http://localhost:5000`. Override using an environment variable:

```powershell
$env:BFF_BASE_URL="http://localhost:5000"
dotnet test
```

## Test Structure

### BFFGatewayIntegrationTests.cs
Contains individual integration tests for each API endpoint:
- **Fleet Management Tests**: Vehicle and driver CRUD operations and status changes
- **Route Management Tests**: Route creation, updates, status changes, and checkpoint management
- **Delivery Management Tests**: Delivery lifecycle, checkpoint updates, incidents, and proof of delivery

### EndToEndWorkflowTests.cs
Contains complete end-to-end workflow tests that simulate real-world scenarios:
- **CompleteDeliveryWorkflow_WithAllSteps_Succeeds**: Full delivery lifecycle from resource creation to completion
- **DeliveryWorkflow_WithLateAssignment_Succeeds**: Testing driver/vehicle assignment after delivery creation
- **DeliveryWorkflow_WithIncidentResolution_Succeeds**: Testing incident reporting and resolution
- **DeliveryWorkflow_WithCancellation_ReleasesResources**: Testing delivery cancellation and resource cleanup

## Key Features

### Auto-Generated IDs
All tests follow the principle of not providing IDs for non-idempotent operations (POST requests). IDs are automatically generated by the API and extracted from responses for subsequent operations.

```csharp
// Example: Creating a vehicle without providing an ID
var response = await _client.PostAsJsonAsync("/api/fleet/vehicles", new
{
    registration = "VAN-001",
    vehicleType = "Delivery Van"
});
var result = await response.Content.ReadFromJsonAsync<dynamic>(_jsonOptions);
var vehicleId = result?.id?.ToString(); // Extract generated ID
```

### Response Chaining
Tests demonstrate proper chaining of operations by using IDs from creation responses in subsequent calls:

```csharp
// Create vehicle
var vehicleResponse = await _client.PostAsJsonAsync("/api/fleet/vehicles", ...);
var vehicleId = (await vehicleResponse.Content.ReadFromJsonAsync<dynamic>())?.id?.ToString();

// Use the generated ID in delivery creation
var deliveryResponse = await _client.PostAsJsonAsync("/api/deliveries", new
{
    routeId,
    vehicleId  // Using the generated ID
});
```

## Running the Tests

### Prerequisites
1. Ensure all microservices (DeliveryTracking, FleetManagement, RouteManagement) are running
2. Redis server must be available for distributed locking
3. Configure service endpoints in appsettings.Testing.json if needed

### Run All Tests
```bash
dotnet test
```

### Run Specific Test Class
```bash
dotnet test --filter "FullyQualifiedName~BFFGatewayIntegrationTests"
dotnet test --filter "FullyQualifiedName~EndToEndWorkflowTests"
```

### Run Specific Test
```bash
dotnet test --filter "FullyQualifiedName~CompleteDeliveryWorkflow_WithAllSteps_Succeeds"
```

### Run with Coverage
```bash
dotnet test --collect:"XPlat Code Coverage"
```

## Test Configuration

### BFFWebApplicationFactory.cs
Custom WebApplicationFactory that sets up the test environment:
- Configures the test host
- Sets environment to "Testing"
- Allows service overrides for testing

### Configuration Override
Create an `appsettings.Testing.json` in the BFF Gateway project if you need to override settings:

```json
{
  "ServiceEndpoints": {
    "DeliveryTrackingBaseUrl": "http://localhost:5001",
    "DeliveryTrackingCommandBaseUrl": "http://localhost:5002",
    "FleetManagementBaseUrl": "http://localhost:5003",
    "FleetManagementCommandBaseUrl": "http://localhost:5004",
    "RouteManagementBaseUrl": "http://localhost:5005",
    "RouteManagementCommandBaseUrl": "http://localhost:5006"
  },
  "ConnectionStrings": {
    "Redis": "localhost:6379"
  }
}
```

## Test Patterns

### Arrange-Act-Assert
All tests follow the AAA pattern:

```csharp
[Fact]
public async Task TestName_Scenario_ExpectedResult()
{
    // Arrange: Set up test data
    var createResponse = await _client.PostAsJsonAsync(...);
    var id = (await createResponse.Content.ReadFromJsonAsync<dynamic>())?.id?.ToString();
    
    // Act: Perform the operation
    var response = await _client.GetAsync($"/api/resource/{id}");
    
    // Assert: Verify the results
    Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    var result = await response.Content.ReadFromJsonAsync<dynamic>();
    Assert.NotNull(result);
}
```

### Test Isolation
Each test is independent and creates its own test data. Tests do not rely on shared state or execution order.

## Best Practices

1. **No Hard-Coded IDs**: Always use auto-generated IDs from creation responses
2. **Clean Assertions**: Use specific status code and content assertions
3. **Meaningful Names**: Test names describe the scenario and expected outcome
4. **Complete Workflows**: E2E tests verify entire business processes
5. **Error Scenarios**: Include tests for validation and error cases

## Troubleshooting

### Tests Failing to Start
- Verify all backend services are running
- Check Redis connection
- Review service endpoint configuration

### Intermittent Failures
- May indicate race conditions or timing issues
- Check service availability and network latency
- Verify distributed locking is working correctly

### Assertion Failures
- Examine test output for actual vs expected values
- Use debugging to inspect response content
- Check API logs for error details

## Future Enhancements

- [ ] Add tests for concurrent operations and race conditions
- [ ] Add performance tests for response times
- [ ] Add tests for error handling and validation
- [ ] Add tests for authentication and authorization
- [ ] Add tests for rate limiting
- [ ] Mock external services for faster test execution
